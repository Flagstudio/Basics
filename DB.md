# Базы данных

## Типы СУБД (SQL, NoSQL) примеры баз

СУБД - системы управления базами данных

Основные типы СУБД:
- SQL, реляционные
  - MySQL
  - PostgreSQL
  - SQLite
- NoSQL, нереляционные
  - Mongo DB
  - Redis
  - MemcacheDB

В данный момент, мы работаем с MySQL, хотя планируем переход на PostgreSQL, так как последняя выигрывает по производительности и функицональности.

Реляционная БД (MySQL) представляет из себя набор таблиц, каждая из которых имеет структуру (столбцы) и данные (строки).

Структура таблиц хранится в нескольких служебных таблицах.

Сами таблицы с данными — это просто файлы, которые лежат на сервере. Но СУБД - это программа, которая управляет этими данными.

## Типы данных в MySQL

Вот они все http://artemfedorov.ru/etc/mysql/field-types/

Важно понимать основные типы:
- Строки, числа, даты и тд
- Наборы значений: set, enum, array (PostgreSQL)
- Внешний ключ (foreign key). Это не тип данных, это обычно INT (число), но принципиально это важно при использовании **связей**

## Laravel

Типы полей в Laravel https://laravel.com/docs/master/migrations#columns

Типы связей в Laravel https://laravel.com/docs/master/eloquent-relationships

Типы полей в Laravel Nova https://nova.laravel.com/docs/2.0/resources/fields.html#fields


### 1 к 1
Связь one-to-one - самая редкоиспользуемая. Может подойти для емейла и пользователя. Но емейл можно внести в самого юзера, поэтому можно обойтись без связи.
Если вы види

### 1 ко многим

Часто используемая связь. Реулизуется через foreign key. Выглядит таким образом.

Таблица Товары

| id  | title            | category |
| --- | ---------------- | -------- |
| 1   | Банан            | 2        |
| 2   | Отбойный молоток | 3        |

Таблица Категории

| id  | title       |
| --- | ----------- |
| 1   | Канцтовары  |
| 2   | Фрукты      |
| 3   | Инструменты |

Как видите, товар относится к категории как "одна категория ко многгим товарам"

### Многие ко многим

Хороший пример для связи "многие-ко-многим" это записи блога и тэги. Один тэг может быть связан со многими статьями, многие статьи могут быть связаны с одним тэгом.
Реализуется через промежуточную таблицу, которую мы называем pivot'ной, а записи в ней pivot'ами.

Таблица Статьи блога (articles)

| id  | title    |
| --- | -------- |
| 1   | Статья 1 |
| 2   | Статья 2 |

Таблица тэги (tags)

| id  | title |
| --- | ----- |
| 2   | Тэг 1 |
| 3   | Тэг 2 |


Промежуточная pivot таблица (article_tag)

| article_id | tag_id |
| ---------- | ------ |
| 2          | 3      |
| 1          | 3      |

В нашем примере мы связали статьи обе статьи с тэгом "Тэг 2".

### Как определить тип связи

Для того, чтобы определить, какой тип связи нужно использовать, используйте такой подход.
Допустим, у нас есть заказы и пользователи.
Задайте вопрос, "может ли быть у юзера несколько заказов?" Затем спросите себя "может ли быть у заказа несколько юзеров?".
Ответы: да, нет. Значит это связь "один юзер ко многим заказам". One-to-many.

### Каскадные удаления

Если у вас есть связь "один ко многим", то есть ребенок и родитель. Например, если у юзера могут быть заказы, то заказ — это ребенок юзера.

Возникает дилемма, как базе данных поступить с детьми, если вы удаляете их родителя. Звучит грустно, но надо принять решение. Поведение базы при удалении родителя легко изменить для каждой связи в любой момент времени. Однако, нужно настроить это поведение, до того, как у произойдет удаление.


Варианты поведения базы при удалении родителя

1. `CASCADE` — то самое каскадное удаление. При удалении родителя удалятся и все его дети по этой связи
2. `SET NULL` — связь сбрасывается и в поле **id родителя** записывается NULL. Это возможно только, если ребенок может быть без родителя, иначе база база будет ругаться и ничего не удалит
3. `RESTRICT` – запрет на удаление родителя, если у него есть дети. самый гуманный вариант, но не всегда подходящий
4. `SET DEFAULT` — установит некое дефолтное (по умолчанию) значение ребенку. Например, какого-то дефолтного родителя

## Миграции (migrations)

### Доставка кода

На каждом нашем проекте есть несколько разных площадок: локальные у разработчиков на компьютерах, тестовая (одна или две) у нас на тестовом сервере и продакшен (боевая площадка, куда ходят реальные посетители).
Постоянная задача при этом - доставлять новые фичи сперва на тестовую площадку с локальной, затем на прод.
Доставкой кода занимается система контроля версий Git и наш CI/CD инструмент Pullkins. CI/CD — это это автоматизация доставки кода и выполнения рутинных операций над ним, например, установки зависимостей, тестирования или выполнения миграций.

### Доставка структуры БД
С кодом все довольно просто, так как есть Git, но что делать с базой данных. Когда прогер изменил структуру какой-то таблицы, как ему перенести это изменение на тестовую площадку?
Для этой задачи используются миграции. Это специальные файлы, которые содержат инструкции по изменению структуры БД, например, добавление столбца в таблице. Каждая миграция - отдельный файл, в котором содержится одно или несколько изменений.
Таким образом, каждый программист, выполнив все миграции, может полностью воссоздать структуру БД.
Надо помнить, что миграции, как правильно, не содержат данных (контента).
Обычно при деплое (публикации) на прд площадку мы не меняем данные в БД, только меняем структуру БД.
Но при деплое на тестовые площадки, мы обычно стираем все данные и заполняем базу тестовой информацией. Это происходит автоматически с помощью Pullkins. Тетосвые данные еще называются сидами.


## Сиды (seed)

Сиды — это специальный механизм в Laravel, который позволяет заполнить базу тестовыми данными. Это позволяет всегда вести разработку на наполненной базе. Это очень удобно, когда программист разворачивает новый проект. Еще это удобно для тестирования нового функционала, программист сразу делает для вас наполнение.
Сиды не существуют без фабрик.
Фабрики (factory) — это программная абстракция, которая генерирует тестовые данные. В Фабриках описано, как создавать данные. А в сидах написано сколько и каких сущностей надо создать. Просто знайте эти понятия, когда нибудь пригодится.
